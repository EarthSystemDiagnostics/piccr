---
title: "piccr: a quick guide on the data processing"
author: "Thomas MÃ¼nch"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    number_sections: false
vignette: >
  %\VignetteIndexEntry{piccr data processing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction {#intro}

This vignette briefly explains the basic principles of the data processing in
**piccr** for correcting and calibrating raw stable isotope data measured on
Picarro Inc. devices. The processing follows in principle the methods presented
in van Geldern and Barth (2012), but offers more refined and additional
options.

We discuss first the basic measurement sequence assumed for the Picarro data
processing with **piccr**, before we present the applied processing steps of
memory correction, calibration, drift correction, and injection
averaging. Finally, we summarise the quality control information offeded by
**piccr** and the basic programme workflow.

## Basic measurement sequence {#sequence}

For discrete stable-isotope measurements it is assumed that sample vials are
measured alongside standard vials with known isotopic composition. A typical
sequence for such measurements, consisting of $N$ vials in total, is three
blocks of standard vials, which are placed at the beginning ($b_1$), in the
middle ($b_2$) and at the end ($b_3$) of the measurement run, together with
sample vials ($s_1$, $s_2$) in between (Fig. \@ref(fig:sequence)). This
configuration allows using all available processing options in **piccr**:

* memory correction based on the $b_1$ standards;
* calibration and drift correction applying $b_1$ and $b_3$ standards;
* quality control from analysing independent standards placed in $b_2$.

A different number of standard blocks is of course possible and supported; a
minimum configuration would be a measurement sequence using only one standard
block $b_1$ at the beginning of the measurement, which, however, would not allow
to monitor and control for potential machine drift.

```{r include = FALSE}
x <- 1 : 40
y <- rep(1, length(x))
dy <- 0.5

b1 <- x[1 : 5]
s1 <- x[6 : 20]
b2 <- x[21 : 23]
s2 <- x[24 : 37]
b3 <- x[38 : 40]
```

```{r sequence, fig.height = 2, fig.width = 7, echo = FALSE, fig.cap = "Sketch of a typical Picarro measurement sequence with alternating blocks of standard ($b_i$) and sample ($s_i$) vials. While a minimum configuration of only one standard block at the beginning of the measurement sequence is possible, a configuration with three blocks of standards allows using the full processing functionality of **piccr**."}
par(mar = c(4, 0.5, 0.5, 0.5))
plot(x, y, type = "n", axes = FALSE, xlim = c(0, 40), ylim = c(0, 2),
     xlab = "", ylab = "")
axis(1, at = c(1, 40), labels = c(1, expression(italic("N"))), tick = TRUE)
mtext("Vial number", side = 1, line = 2)
box()

xx <- b1
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression(italic("b")[1]))

xx <- s1
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), border = "dodgerblue3", lwd = 2)
text(mean(xx), mean(yy), expression(italic("s")[1]), col = "dodgerblue3")

xx <- b2
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression(italic("b")[2]))

xx <- s2
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), border = "dodgerblue3", lwd = 2)
text(mean(xx), mean(yy), expression(italic("s"[2])), col = "dodgerblue3")

xx <- b3
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression(italic("b")[3]))
```

## Memory correction {#memory}

### Definitions

The memory effect refers to the carry-over of residual amounts of water vapour
in the device's measurement cavity from one injection to the other, which leads
to contamination of the measured isotope value.

To quantifiy this effect, we assume two vials with different standard isotopic
compositions ("delta values" in the following); each vial is injected $n$ times
into the cavity of the measurement device. Further, let $\delta_v$ denote the
true delta value of a standard vial, where $\delta_v^{(1)}$ refers to the first
standard and $\delta_v^{(2)}$ to the second standard vial, and let
$\delta_c^{j}$ denote the delta value of the water vapour in the cavity for
injection $j$. The memory effect for this injection can then be approximated by
assuming that the delta value of the water vapour in the cavity is a weighted
mean of the true value of the injected vial and the cavity value from the
previous injection,

\begin{equation}
  \delta_c^{j}=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j-1},
  (\#eq:one)
\end{equation}

where $\tilde{m}$ is the general memory coefficient of the measurement
system, which quantifies the fraction of water vapour in the cavity which stems
from the previous injection. Likewise, for injections $j+1$ and $j+2$ we have

\begin{align}
  \delta_c^{j+1}&=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j}, (\#eq:two)\\
  \delta_c^{j+2}&=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j+1}. (\#eq:three)
\end{align}

By inserting $\delta_c^{j}$ into $\delta_c^{j+1}$ and  $\delta_c^{j+1}$ into
$\delta_c^{j+2}$, one finds for injection $j+k$

\begin{equation}
  \delta_c^{j+k} = (1-\tilde{m}^{k+1})\delta_v + \tilde{m}^{k+1}\delta_c^{j-1}.
  (\#eq:four)
\end{equation}

We now set $i=j+k$ and define $j$ to be first injection from the second standard
vial, thus $j=1$. Then, the cavity value of the previous injection,
$\delta_c^{j-1}$, is the last injection from the first standard vial and thus
very close to the true value for that vial,
$\delta_c^{j-1}\approx\delta_v^{(1)}$. The cavity value for injection $i$ from
the second standard vial is thus in general

\begin{equation}
  \delta_c^{i} = (1-\tilde{m}^{i})\delta_v^{(2)} + \tilde{m}^{i}\delta_v^{(1)}.
  (\#eq:mem-effect)
\end{equation}

From here, we can define the injection-specific memory coefficient as

\begin{equation}
  m_i:=1-\tilde{m}^{i},
  (\#eq:mem-coef-spec)
\end{equation}

which describes the fraction of vapour in the cavity which stems from the
current injection $i$. By combining Eqs. \@ref(eq:mem-effect) and
\@ref(eq:mem-coef-spec), one can derive an expression for $m_i$,

\begin{equation}
  m_i = \frac{\delta_c^{i} - \delta_v^{(1)}}{\delta_v^{(2)} - \delta_v^{(1)}}.
(\#eq:mem-coef-est)
\end{equation}

### Correcting for the memory effect

The memory-corrected value for an injection $i$ from the second standard vial,
$\delta_{\text{mem.-corr.}}^{i}$, is the true delta value for this vial,
i.e. $\delta_v^{(2)}$. Solving Eq. \@ref(eq:mem-effect) for $\delta_v^{(2)}$ and
using Eq. \@ref(eq:mem-coef-spec) yields

\begin{equation}
  \begin{split}
  \delta_{\text{mem.-corr.}}^{i} &= 
  \delta_c^{i} + \frac{1-m_i}{m_i}\left(\delta_c^{i} - \delta_v^{(1)}\right),\\
  &\approx \delta_c^{i} + 
  \left(1-m_i\right)\left(\delta_c^{i} - \delta_v^{(1)}\right)
  \ \text{for}\ m_i \lesssim 1,\\
  &=\delta_c^{i} + \tilde{m}^{i}\left(\delta_c^{i} - \delta_v^{(1)}\right).
  \end{split}
  (\#eq:delta-mem-corr)
\end{equation}

In **piccr**, the full expression, i.e. the first line of
Eq. \@ref(eq:delta-mem-corr), is used for the correction. The second line is the
approximation as given in van Geldern and Barth (2012).

### Estimating and applying the memory coefficients

To estimate the memory coefficients for a specific measurement sequence, $N_s$
standard vials with different isotopic composition are placed in block
$b_1$. Each standard is injected $n_I$ times, where $n_I$ needs to be large
enough to ensure that the measured values of the last injections are close to
the true value of the vial (e.g., $n_I = 12$). From the raw measurement data for
each standard of number $2$ to $N_s$, memory coefficients in **piccr** are then
estimated as follows:
 
* The $m_i$ for each standard are estimated from Eq. \@ref(eq:mem-coef-est). For
this, the $\delta_v$ values are approximated with the mean across the last three
injections of the respective standard.
* The mean $m_i$ across the $N_s-1$ standards are calculated and applied for the
correction in Eq. \@ref(eq:delta-mem-corr).

## Calibration and drift correction {#calib-drift}

### Calibration

The raw output data (i.e. memory-corrected or not) from Picarro Inc. devices
need to be calibrated to the international VSMOW/SLAP scale of water isotopic
composition. For this, standards with known isotopic composition are used. 

In **piccr**, the calibration is performed by linearly regressing the true
values of $N_s$ standards measured in some block $b_i$ against the measured
values from the injections. The number of calibration standards $N_s$ is
settable: naturally, the minimum is to use two calibration standards, but it is
also possible to use three or all standards from the block. If memory correction
has been applied, all injections are used for the regression, else only the last
three injections to avoid the memory effect from affecting the calibration.

``` {r include = FALSE}
set.seed(20190813)

s1 <- -33.9
s2 <- -42.5
s3 <- -50.22

y <- c(s1, s2, s3)

e1 <- rnorm(3, 0, 0.5)
e2 <- rnorm(3, 0, 0.5)
e3 <- rnorm(3, 0, 0.5)

dx.const <- 3
dx.var <- c(0, 2, 4)

x1 <- y + e1
x2 <- y + e1 + dx.const
x3 <- y + e3 + dx.var
```

```{r calibration, fig.height = 3, fig.width = 7, echo = FALSE, fig.cap ="Schematic sketch of a linear calibration regression using three standards. (**Left**) The regression from the initial standard block $b_1$ is compared to the regression from the final standard block $b_3$ assuming a constant, linear drift of the measurement values over time, which changes the calibration intercept at the final compared to the initial block but leaves the calibration slope unchanged. (**Right**) Same as (left) but assuming a linear drift that is stronger for more negative delta values. This changes both the calibration slope and intercept at the final block. Note that for visibility, the magnitude of the device drift is exaggerated in both examples."}
par(mar = c(4, 4, 0.5, 0.5))
par(mfcol = c(1, 2), las = 1)
plot(x1, y, type = "n", axes = FALSE, xlim = c(-55, -30), ylim = c(-60, -25),
     xlab = bquote("Measured " * delta), ylab = bquote("True " * delta))
axis(1)
axis(2, at = seq(-55, -30, 5))
box()

points(x1, y, pch = 19, col = "black")
abline(lm(y ~ x1), lwd = 2, col = "black")

points(x2, y, pch = 19, col = "dodgerblue")
abline(lm(y ~ x2), lwd = 2, col = "dodgerblue")

legend("topleft", c("initial calibration", "final calibration"),
       lwd = 2, lty = 1, col = c("black", "dodgerblue"), bty = "n")

plot(x1, y, type = "n", axes = FALSE, xlim = c(-55, -30), ylim = c(-60, -25),
     xlab = bquote("Measured " * delta), ylab = bquote("True " * delta))
axis(1)
axis(2, at = seq(-55, -30, 5))
box()

points(x1, y, pch = 19, col = "black")
abline(lm(y ~ x1), lwd = 2, col = "black")

points(x3, y, pch = 19, col = "firebrick")
abline(lm(y ~ x3), lwd = 2, col = "firebrick")

legend("topleft", c("initial calibration", "final calibration"),
       lwd = 2, lty = 1, col = c("black", "firebrick"), bty = "n")
```

The linear regression yields a calibration intercept $I$ and a calibration slope
$s$ (as illustrated by the black lines in Fig. \@ref(fig:calibration)). The raw
measurement data are then calibrated to the true scale using

\begin{equation}
  \delta_\text{calib} = s\cdot\delta_\text{raw} + I.
  (\#eq:calibration)
\end{equation}


### Drift

For longer measurement runs Picarro Inc. devices exhibit drift (van Geldern and
Barth, 2012), i.e. the measured delta values gradually shift over
time. This has an influence on the calibration parameters depending on the type
of the drift.

#### Constant linear drift

Assuming a constant linear drift, the measured data drifts at the same rate
independent of the delta value (Fig. \@ref(fig:calibration), left). **piccr**
estimates this kind of drift by linearly regressing the standards commonly
measured in all three blocks $b_1$--$b_3$ against the measurement time relative
to $b_1$. Again, only if memory correction was applied, all standard injections
are used for this, else only the last three. The regression yields a regression
slope for each standard (Fig. \@ref(fig:drift)), and the drift rate $\alpha$ is
estimated with the average regression slope. Then, the measured
(memory-corrected) delta values are drift-corrected using

\begin{equation}\label{eq:drift.corr.}
  \delta_\text{drift-corr.} = \delta_\text{mem.-corr.} - \alpha t,
  (\#eq:drift-corr)
\end{equation}

where $t$ is the measurement time (van Geldern and Barth, 2012).

Subsequently, a calibration is performed using the calibration parameters
calculated from the standards in $b_1$ (intercept $I_1$, slope $s_1$) and
applying Eq. \@ref(eq:calibration).

```{r include = FALSE}
set.seed(20190814)

slope <- 1

x <- rep(0 : 2, each = 3) + c(0, 0.1, 0.2)
y.drift <- -33.9 + rnorm(9, 0, 0.1) + slope * x

```

```{r drift, fig.height = 3, fig.width = 7, echo = FALSE, fig.cap ="Schematic sketch of a device drift with a constant rate that gradually shifts the measured delta values of a given standard over time."}
par(mar = c(4, 4, 0.5, 0.5))
par(las = 1)
plot(x, y.drift, type = "n", axes = FALSE, xlim = c(0, 2.25), ylim = c(-35, -31),
     xlab = "Measurement time (a.u.)", ylab = bquote("Measured " * delta * " (a.u.)"))
axis(1, at = 0 : 2)
axis(2)
box()

abline(h = y[1], col = "darkgrey", lty = 2)
points(x, y.drift, pch = 19, col = "black")
abline(lm(y.drift ~ x), lwd = 2, col = "dodgerblue")
```

Approximately, this correction can be interpreted jointly as a time-variable
calibration (Fig. \@ref(fig:calibration), left) with a constant calibration
slope, but where the calibration intercept varies linearly with time between
$b_1$ and $b_3$ according to the drift rate $\alpha$,

\begin{equation}
  \begin{split}
    I(t) &= I_1 + \alpha t,\\
    s(t) &= s_1 = \text{const.}
  \end{split}
  (\#eq:joint-calib-one)
\end{equation}

#### Delta-dependent linear drift

More generally, the device can exhibit a linear drift that is not constant but
dependent on the delta value. Such a drift pattern does not only affect the
calibration intercept but also the calibration slope over time
(Fig. \@ref(fig:calibration), right), and a time-dependent calibration has to be
defined according to

\begin{equation}
  \begin{split}
    I(t) &= I_1 + \alpha t,\\
    s(t) &= s_1 + \beta t.
  \end{split}
  (\#eq:joint-calib-two)
\end{equation}

Here, $\alpha$ and $\beta$ are the rates at which the calibration parameters
change over time.

To estimate $\alpha$ and $\beta$, **piccr** calculates calibration parameters
(i.e. intercept and slope) from both the $b_1$ and $b_3$ blocks and regresses
these parameters against the measurement time. The slopes of each regression
then yield the $\alpha$ and $\beta$ rates, respectively. More specifically, the
$b_1$ calibration yields the calibration parameters $I_1$ and $s_1$, and the
$b_3$ calibration the calibration parameters $I_3$ and $s_3$. Then, the drift
rates are given by

\begin{align}
  \alpha \simeq \frac{I_3 - I_1}{\Delta t}, (\#eq:drift-rates-one)\\
  \beta \simeq \frac{s_3 - s_1}{\Delta t}, (\#eq:drift-rates-two)
\end{align}

where $\Delta t$ is the measurement time that passed between $b_1$ and
$b_3$. The raw (memory-corrected) data are then jointly drift-corrected and
calibrated using the $I(t)$ and $s(t)$ of Eq. \@ref(eq:joint-calib-two) in
Eq. \@ref(eq:calibration).

## Sample value from injection average {#averaging}

To increase measurement precision, the final isotopic value of a given measured
sample after all previous processing steps is obtained from averaging across a
given number of injections. Without memory correction, the first injections
should be discarded from the average to limit the influence of the memory effect
on the mean sample value. However, since **piccr** provides an active memory
correction, all injections can be used to calculate the sample average.

The possible options in **piccr** to perform this averaging step therefore are:

* average over all available injections for each sample;
* average across the last $n$ injections;
* average across a range of injections from injection number $n_1$ to $n_2$.

## Quality control {#qcontrol}

Quality control of the measured and processed data is possible with **piccr** on
four levels: (1) per-injection basis, (2) per-sample basis, (3) per-file basis,
and (4) per-project basis.

These information are based on actual data measured by the Picarro device,
on parameter data from the **piccr** processing steps, and on data obtained from
the deviations of the measured and processed standard values compared to their
expected ("true") values. For this, it is recommended to use an independent
quality control standard in the measurement, which is not used for any
processing steps and is preferably placed in the $b_2$ block.

### Per-injection basis

On this level, the following quality control information is obtained directly
from the Picarro measurement files:

* standard deviation of the injection value for each measured isotopic species
  from the measurement integration time in the cavity;
* water vapour level (mean and standard deviation) during the injection.

The cavity water vapour level during an injection should typically lie between
18000 and 22000 ppm. Deviations from this optimal range may result in large
standard deviations of the measured isotope values. Taken together, these
information can be used to sort out "bad" injections.

Since **piccr** also returns the raw data, as read in from the measurement
files, these quality control information are readily available for further
analysis.

### Per-sample basis

The final isotopic value of the sample is obtained from averaging across a
certain number of injections ([see above](#averaging)). From this injection
average, **piccr** calculates the following quality control information:

* the mean water vapour level and its standard deviation;
* the standard deviation of the mean isotope value for each isotopic species;
* the deviation from the true isotope value (only for standards).

These data are a measure for the overall goodness of the measured value of the
sample and can provide information on the stability of consecutive measurements
or help to identify outliers.

### Per-file basis

On this level, **piccr** provides the following quality control information:

* the specific deviation from the true value for the independent quality control
  standard;
* the root mean square deviation across the deviations of all measured standards
  from their true values;
* the pooled standard deviation across all measured samples and standards;
* quality control information from the memory correction process: mean memory
  coefficients and the individual coefficients as estimated from each analysed
  standard;
* quality control information from the calibration process (_to be specified_);
* quality control information from the drift correction process (_to be
  specified_).

The deviation of the independent quality control standard, and the root mean
square deviation of all measured standard values from their true values serve as
an overall measurement uncertainty for the run. The root mean square deviation
is defined as

\begin{equation}
  \sigma_\text{rmsd} = 
  \sqrt{\frac{1}{k}\sum_{i=1}^{k}{\left(\Delta\delta_i\right)^2}},
  (\#eq:rmsd)
\end{equation}

where $\Delta \delta_i$ is the deviation of the measured value from its true
value for standard $i$, $\Delta\delta_i=\delta_t - \delta_m$, and $k$ is the
number of standards.

The pooled standard deviation $\sigma_\text{p}$ is the square root of the pooled
variance which is defined as

\begin{equation}
  \sigma_\text{p}^2 =
  \frac{\sum_{i=1}^{N}{(n_i-1)\sigma_i^2}}{\sum_{i=1}^{N}{(n_i-1)}},
  (\#eq:sigma-pooled)
\end{equation}

where $\sigma_i$ is the standard deviation of the mean isotope value for vial
$i$ from averaging across $n_i$ injections, and $N$ is the total number of
analysed vials. The pooled variance is an estimate of the fixed common variance
from populations that have different means. If the number of injections is the
same for all vials (populations), $n_i=n=\text{const}$, the pooled variance is
simply the average across all variances $\sigma_i^2$. The pooled standard
deviation provides a measure for the overall stability of consecutive
injections.

### Per-project basis

The overall measurement uncertainty for a given measurement project, which
contains $M$ single measurements (i.e. Picarro files), is assessed with
the root mean square deviation of the quality control standards,

\begin{equation}
  \sigma_\text{rmsd}^{\text{project}} = 
  \sqrt{\frac{1}{M}\sum_{i=1}^{M}{\left(\Delta\delta_{i}^{\text{qlty-contr}}\right)^2}},
  (\#eq:qlty-contr)
\end{equation}

where $\Delta\delta_{i}^{\text{qlty-contr}}$ is the deviation for measurement
file $i$ of the quality control standard from its true value (either the simple
deviation, or the root mean square deviation if more than one independent
quality control standards have been used in this file).

## Programme work flow

In summary, the basic programme workflow in **piccr** for correcting and
calibrating the raw data is:

1.
if (use\_memory\_correction):
    + calculate memory coefficients;
    + apply memory correction, Eq. \@ref(eq:delta-mem-corr).

2.
if (no\_drift\_correction):
    + obtain calibration intercept and slope from $b_1$ standards;
    + apply calibration, Eq. \@ref(eq:calibration).

    else if (use\_simple\_drift\_correction):
    + calculate drift slope $\alpha$;
    + drift-correct data, Eq. \@ref(eq:drift-corr);
    + obtain calibration intercept and slope from $b_1$ standards;
    + apply calibration, Eq. \@ref(eq:calibration).

    else if (use\_double\_calibration):
    + obtain calibration intercept and slope from $b_1$ and $b_3$ standards;
    + linearly regress calibration parameters between $b_1$ and $b_3$,
    Eqs. \@ref(eq:drift-rates-one)--\@ref(eq:drift-rates-two);
    + apply calibration, Eq. \@ref(eq:joint-calib-two) and
    Eq. \@ref(eq:calibration).

3.
calculate average values across injections.

4.
obtain quality control information.


## References

van Geldern, R. and Barth, J. A.: Optimization of instrument setup and post-run
corrections for oxygen and hydrogen stable isotope measurements of water by
isotope ratio infrared spectroscopy (IRIS), Limnol. Oceanogr. Methods, 10,
1024â1036,
DOI: [10.4319/lom.2012.10.1024](https://doi.org/10.4319/lom.2012.10.1024), 2012.

