---
title: "piccr: a quick guide on data processing"
author: "Thomas MÃ¼nch"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{piccr data processing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This document briefly explains the basic principles of the data processing in
**piccr**, the [R package](https://github.com/EarthSystemDiagnostics/piccr) for
correcting and calibrating raw stable isotope data measured on Picarro
Inc. devices.

## Basic measurement sequence

For discrete stable-isotope measurements, sample vials are measured alongside
standard vials with known isotopic composition. The typical sequence for such
measurements, consisting of $N$ vials in total, is three blocks of standard
vials, which are placed at the beginning (b~1~), in the middle (b~2~) and at the
end (b~3~) of the measurement run, together with sample vials (s~1~, s~2~) in
between (Fig. \ref{fig:sequence}).

```{r include = FALSE}
x <- 1 : 40
y <- rep(1, length(x))
dy <- 0.5

b1 <- x[1 : 5]
s1 <- x[6 : 20]
b2 <- x[21 : 23]
s2 <- x[24 : 37]
b3 <- x[38 : 40]
```

```{r fig.height = 3, fig.width = 8, echo = FALSE, fig.cap = "\\label{fig:sequence}Sketch of a typical Picarro measurement sequence with alternating blocks of standard ($b_i$) and sample ($s_i$) vials."}
plot(x, y, type = "n", axes = FALSE, xlim = c(0, 40), ylim = c(0, 2),
     xlab = "", ylab = "")
axis(1, at = c(1, 40), labels = c(1, "N"), tick = TRUE)
mtext("Vial number", side = 1, line = 2)
box()

xx <- b1
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression("b"[1]))

xx <- s1
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), border = "dodgerblue3", lwd = 2)
text(mean(xx), mean(yy), expression("s"[1]), col = "dodgerblue3")

xx <- b2
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression("b"[2]))

xx <- s2
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), border = "dodgerblue3", lwd = 2)
text(mean(xx), mean(yy), expression("s"[2]), col = "dodgerblue3")

xx <- b3
yy <- y[xx]
polygon(c(xx, rev(xx)), c(yy - dy, yy + dy), lwd = 2)
text(mean(xx), mean(yy), expression("b"[3]))

```

## Memory correction

### Definitions

The memory effect refers to the carry-over of residual amounts of water vapour
in the device's measurement cavity from one injection to the other, which leads
to contamination of the measured isotope value.

To quantifiy this effect, we assume two vials with different standard isotopic
compositions ("delta values" in the following); each vial is injected $n$ times
into the cavity of the measurement device. Further, let $\delta_v$ denote the
true delta value of a standard vial, where $\delta_v^{(1)}$ refers to the first
standard and $\delta_v^{(2)}$ to the second standard vial, and let
$\delta_c^{j}$ denote the delta value of the water vapour in the cavity for
injection $j$. The memory effect for this injection can then be approximated by
assuming that the delta value of the water vapour in the cavity is a weighted
mean of the true value of the injected vial and the cavity value from the
previous injection,

\begin{equation}
\delta_c^{j}=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j-1},
\end{equation}

where $\tilde{m}$ is the general memory coefficient of the measurement
system, which quantifies the fraction of water vapour in the cavity which stems
from the previous injection. Likewise, for injections $j+1$ and $j+2$ we have

\begin{align}
\delta_c^{j+1}&=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j},\\
\delta_c^{j+2}&=(1-\tilde{m})\delta_v + \tilde{m}\delta_c^{j+1}.
\end{align}

By inserting $\delta_c^{j}$ into $\delta_c^{j+1}$ and  $\delta_c^{j+1}$ into
$\delta_c^{j+2}$, one finds for injection $j+k$

\begin{equation}
\delta_c^{j+k} = (1-\tilde{m}^{k+1})\delta_v + \tilde{m}^{k+1}\delta_c^{j-1}.
\end{equation}

We now set $i=j+k$ and define $j$ to be first injection from the second standard
vial, thus $j=1$. Then, the cavity value of the previous injection,
$\delta_c^{j-1}$, is the last injection from the first standard vial and thus
very close to the true value for that vial,
$\delta_c^{j-1}\approx\delta_v^{(1)}$. The cavity value for injection $i$ from
the second standard vial is thus in general

\begin{equation}\label{eq:mem.effect}
\delta_c^{i} = (1-\tilde{m}^{i})\delta_v^{(2)} + \tilde{m}^{i}\delta_v^{(1)}.
\end{equation}

From here, we can define the injection-specific memory coefficient as

\begin{equation}\label{eq:mem.coef.spec}
m_i:=1-\tilde{m}^{i},
\end{equation}

which describes the fraction of vapour in the cavity which stems from the
current injection $i$. Combining Eqs. (\ref{eq:mem.effect}) and
(\ref{eq:mem.coef.spec}), one can derive an expression for $m_i$,

\begin{equation}\label{eq:mem.coef.est}
m_i = \frac{\delta_c^{i} - \delta_v^{(1)}}{\delta_v^{(2)} - \delta_v^{(1)}}.
\end{equation}

### Correcting for the memory effect

The memory-corrected value for an injection $i$ from the second standard vial,
$\delta_{\text{mem.-corr.}}^{i}$, is the delta value for this vial,
$\delta_v^{(2)}$. To derive an expression for the correction, we may thus write
$\delta_{\text{mem.-corr.}}^{i} = 
\delta_c^{i} + \left(\delta_v^{(2)} - \delta_c^{i}\right)$
and use Eqs. (\ref{eq:mem.effect}--\ref{eq:mem.coef.est}) to obtain

\begin{equation}\label{eq:delta.mem.corr.}
\begin{split}
\delta_{\text{mem.-corr.}}^{i} &= 
\delta_c^{i} + \frac{1-m_i}{m_i}\left(\delta_c^{i} - \delta_v^{(1)}\right),\\
&\approx \delta_c^{i} + 
\left(1-m_i\right)\left(\delta_c^{i} - \delta_v^{(1)}\right)
\ \text{for}\ m_i \lesssim 1,\\
&=\delta_c^{i} + \tilde{m}^{i}\left(\delta_c^{i} - \delta_v^{(1)}\right).
\end{split}
\end{equation}

### Estimating memory coefficients

To estimate the memory coefficients for a specific measurement sequence, $N_s$
standard vials with different isotopic composition are placed in block
$b_1$. Each standard is injected $n_I$ times (typically, $n_I = 12$). From the
raw measurement data for each standard of number $2$ to $N_s$, memory
coefficients can then be estimated in three different ways:

1. 
Estimate the $m_i$ for each standard from Eq. (\ref{eq:mem.coef.est}). For this,
the $\delta_v$ values are approximated by the last injection of the respective
standard (alternatively, one could also use the mean across the last 3
injections of the  respective standard). Take the average $m_i$ across the
$N_s-1$ standards used (currently implemented in **piccr**).
2. 
Estimate the $m_i$ as before and fit an exponential of the form
$1-\exp(-\mu\cdot i)$,
where $i$ is the injection number and $\mu$ the fit parameter. From the fit
parameter, the general memory coefficient follows as
$\tilde{m}=e^{-\mu}$.
3. 
Estimate the $m_i$ by minimising the combined standard deviation of the
injections across the $N_s$ standards; see the description in van Geldern and
Barth (2012). This method is not yet impemented in **piccr** but could lead to
more accurate memory corrections.

## Calibration and drift correction

### Calibration

The raw output data (i.e. memory-corrected or not) from Picarro Inc. devices
need to be calibrated to the international VSMOW/SLAP scale of water isotopic
composition. For this, standards with known isotopic composition are used. The
calibration is performed by linearly regressing the true values of $N_s$
standards measured in block $b_i$ against the measured values from the
injections (if memory correction is applied, all injections can be used, else
only the last three injections to avoid the memory effect from affecting the
calibration). [Note: Here, we need to decide whether to take all injections of
each standard or the mean across the injections.]

```{r include = FALSE}
set.seed(20190813)

s1 <- -33.9
s2 <- -42.5
s3 <- -50.22

y <- c(s1, s2, s3)

e1 <- rnorm(3, 0, 0.5)
e2 <- rnorm(3, 0, 0.5)
e3 <- rnorm(3, 0, 0.5)

dx.const <- 3
dx.var <- c(0, 2, 4)

x1 <- y + e1
x2 <- y + e1 + dx.const
x3 <- y + e3 + dx.var
```


```{r fig.height = 4, fig.width = 8, echo = FALSE, fig.cap = "\\label{fig:calibration}Schematic sketch of a linear calibration regression using three standards. (**Left**) The regression from the initial standard block $b_1$ is compared to the regression from the final standard block $b_3$ assuming a constant, linear drift of the measurement values over time, which changes the calibration intercept at the final compared to the initial block but leaves the calibration slope unchanged. (**Right**) Same as (left) but assuming a linear drift that is stronger for more negative delta values. This changes both the calibration slope and intercept at the final block. Note that for visibility, the magnitude of the device drift is exaggerated in both examples."}
par(mfrow = c(1, 2), las = 1)
plot(x1, y, type = "n", axes = FALSE, xlim = c(-55, -30), ylim = c(-60, -25),
     xlab = bquote("Measured " * delta), ylab = bquote("True " * delta))
axis(1)
axis(2, at = seq(-55, -30, 5))
box()

points(x1, y, pch = 19, col = "black")
abline(lm(y ~ x1), lwd = 2, col = "black")

points(x2, y, pch = 19, col = "dodgerblue")
abline(lm(y ~ x2), lwd = 2, col = "dodgerblue")

legend("topleft", c("initial calibration", "final calibration"),
       lwd = 2, lty = 1, col = c("black", "dodgerblue"), bty = "n")

plot(x1, y, type = "n", axes = FALSE, xlim = c(-55, -30), ylim = c(-60, -25),
     xlab = bquote("Measured " * delta), ylab = bquote("True " * delta))
axis(1)
axis(2, at = seq(-55, -30, 5))
box()

points(x1, y, pch = 19, col = "black")
abline(lm(y ~ x1), lwd = 2, col = "black")

points(x3, y, pch = 19, col = "firebrick")
abline(lm(y ~ x3), lwd = 2, col = "firebrick")

legend("topleft", c("initial calibration", "final calibration"),
       lwd = 2, lty = 1, col = c("black", "firebrick"), bty = "n")

```

The linear regression yields a calibration intercept $I$ and a calibration
slope $s$ (black lines in Fig. \ref{fig:calibration}). The raw measurement
data are then calibrated to the true scale using

\begin{equation}\label{eq:calibration}
\delta_\text{calib} = s\cdot\delta_\text{raw} + I.
\end{equation}

### Drift

For longer measurement runs Picarro Inc. devices exhibit drift (van Geldern and
Barth, 2012), i.e. the measured delta values gradually shift over
time. This has an influence on the calibration parameters depending on the type
of the drift.

#### Constant linear drift

For a constant linear drift, the measured data is assumed to drift at the same
rate independent of the delta value. To estimate such a drift, standards from
all three blocks $b_1$--$b_3$ are regressed against the measurement time
relative to $b_1$. This yields a regression slope for each standard
(Fig. \ref{fig:drift}), and the drift rate $\alpha$ is estimated from the
average regression slope.

```{r include = FALSE}
set.seed(20190814)

slope <- 1

x <- rep(0 : 2, each = 3) + c(0, 0.1, 0.2)
y.drift <- -33.9 + rnorm(9, 0, 0.1) + slope * x
```

```{r fig.height = 4, fig.width = 8, echo = FALSE, fig.cap ="\\label{fig:drift}Schematic sketch of a device drift with a constant rate that gradually shifts the measured delta values of a given standard over time."}
par(las = 1)
plot(x, y.drift, type = "n", axes = FALSE, xlim = c(0, 2.25), ylim = c(-35, -31),
     xlab = "Measurement time (a.u.)", ylab = bquote("Measured " * delta * " (a.u.)"))
axis(1, at = 0 : 2)
axis(2)
box()

abline(h = y[1], col = "darkgrey", lty = 2)
points(x, y.drift, pch = 19, col = "black")
abline(lm(y.drift ~ x), lwd = 2, col = "dodgerblue")
```

To correct for this drift pattern, one can apply the drift rate to the
measured (memory-corrected) delta values,

\begin{equation}\label{eq:drift.corr.}
\delta_\text{drift-corr.} = \delta_\text{mem.-corr.} - \alpha t,
\end{equation}

where $t$ is the measurement time (van Geldern and Barth, 2012). Subsequently,
one calculates the calibration parameters from the standards in $b_1$ (intercept
$I_1$, slope $s_1$), and then applies Eq. (\ref{eq:calibration}). This is
currently implemented in the original **piccr** version.

If we neglect the small difference in measurement time that passes between the
first and last calibration standards in $b_1$ and $b_3$ due to different
injection numbers, we can alternatively interpret this drift pattern as a
time-variable calibration, where the calibration intercept varies linearly with
time between $b_1$ and $b_3$ according to the drift rate $\alpha$
(Fig. \ref{fig:calibration}a):

\begin{subequations}
\begin{align}
I(t) &= I_1 + \alpha t,\\
s(t) &= s_1 = \text{const.}.
\end{align}
\end{subequations}

This allows for a more concise implementation by correcting this drift pattern
through estimating $\alpha$ and then applying $I(t)$ and $s(t)$ in
Eq. (\ref{eq:calibration}) to drift-correct and calibrate the data at the same
time.

Note:

Due to the minor approximation underlying the second approach, I do not expect
both approaches to yield the exact same results (opposed to what I said
earlier). Therefore, for testing purposes, I would suggest to use the first
approach again in our re-implementation of **piccr** and leave the
implementation of the second approach for later. We should maybe discuss this
once more.

#### Delta-dependent linear drift

More generally, the device could exhibit a linear drift that is not constant but
dependent on the delta value. Such a drift pattern does not only affect the
calibration intercept but also the calibration slope over time
(Fig. \ref{fig:calibration}b), and a time-dependent calibration has to be defined
according to

\begin{subequations}
\begin{align}
I(t) &= I_1 + \alpha t,\\
s(t) &= s_1 + \beta t.
\end{align}
\end{subequations}

Here, $\alpha$ and $\beta$ are the rates at which the calibration parameters
change over time. They can be estimated from the measurement by calculating
calibration parameters (i.e. intercept and slope) from both the $b_1$ and $b_3$
blocks (or, additionally, from the $b_2$ block), and regressing these parameters
against the measurement time. The slopes of each regression then yield the
$\alpha$ and $\beta$ rates, respectively. More specifically, the $b_1$
calibration yields $I_1$ and $s_1$, the $b_3$ calibration $I_3$ and $s_3$. Then,
the rates are given by

\begin{align}
\alpha \simeq \frac{I_3 - I_1}{\Delta t},\\
\beta \simeq \frac{s_3 - s_1}{\Delta t}.
\end{align}

The raw (memory-corrected) data are
then drift-corrected and calibrated using $I(t)$ and $s(t)$ in
Eq. (\ref{eq:calibration}).

## Sample value from injection average

To reduce measurement uncertainty, the isotopic value of a given measured sample
should be obtained from averaging a given number of injections. Without memory
correction, the first injections should be discarded from the average to limit
the influence of the memory effect on the mean sample value. However, since
**piccr** provides an active memory correction, all injections can be used to
calculate the sample average. 

Hence, possible options in **piccr** include to average over all injections (set
the correponding parameter in the _YAML_ configuration file to "all"), or to
average across the last $n$ injections (set the parameter to $n$).

## Quality control

Quality control of the measured and processed data is possible with **piccr** on
three levels: on (1) a per-injection basis, (2) a per-sample basis, and (3) a
per-file basis.

### Per-injection basis

On this level, the following quality control information is obtained directly
from the Picarro measurement files:

* standard deviation of the injection value for each measured isotopic species
  from the measurement integration time in the cavity;
* water vapour level (mean and standard deviation) during the injection.

The cavity water vapour level during an injection should typically lie between
$18000$ and $22000\,\text{ppm}$. Deviations from this optimal range may result
in large standard deviations of the measured isotope values. Taken together,
these information can be used to sort out "bad" injections.

Since **piccr** also returns the raw data, as read in from the measurement files,
these quality control information are readily available for further analysis.

### Per-sample basis

The isotopic value of the sample is obtained from averaging across a certain
(settable) number of injections. From the injection average, **piccr**
calculates the following quality control information:

* the mean water vapour level and its standard deviation;
* the standard deviation of the mean isotope value for each isotopic species;
* the deviation from the true isotope value (only for standards).

These data are a measure for the overall goodness of the measured value of the
sample and can provide information on the stability of consecutive measurements
or help to identify outliers.

The deviation of the measured standard values from their true values is used to
calculate an overall measurement uncertainty for the run (per-file basis, see
below).

### Per-file basis

On the per-file basis, **piccr** provides the following quality control
information:

* the specific deviation from the true value for the independent quality control
  standard;
* the root mean square deviation across the deviations of all measured standards
  from their true values;
* the pooled standard deviation across all measured samples and standards;
* quality control information from the memory correction process (memory
  coefficients: mean values and values for each analysed standard);
* quality control information from the calibration process (such as standard
  deviation of residuals, p-value of regression) [tbd];
* quality control information from the drift correction process (drift slopes,
  p-value of regression) [tbd].
  
Here, the root mean square deviation is defined as

\begin{equation}\label{eq:rmsd}
\sigma_\text{rmsd} = 
\sqrt{\frac{1}{k}\sum_{i=1}^{k}{\left(\Delta\delta_i\right)^2}},
\end{equation}

where $\Delta \delta_i$ is the deviation for standard $i$ of the measured value
from its true value, $\Delta\delta_i=\delta_t - \delta_m$, and $k$ is the number
of standards; and the pooled standard deviation $\sigma_\text{p}$ is the square
root of the pooled variance which is defined as

\begin{equation}\label{eq:sigma.pooled}
\sigma_\text{p}^2 =
\frac{\sum_{i=1}^{N}{(n_i-1)\sigma_i^2}}{\sum_{i=0}^{N}{(n_i-1)}},
\end{equation}

where $\sigma_i$ is the standard deviation of the mean isotope value for vial
$i$ from averaging across $n_i$ injections, and $N$ is the total number of
analysed vials. The pooled variance is an estimate of the fixed common variance
from populations that have different means. If the number of injections is the
same for all vials (populations), $n_i=n=\text{const}$, the pooled variance is
simply the average across all variances $\sigma_i^2$.

The overall measurement uncertainty for a given measurement project, which
contains $M$ single measurements (i.e. Picarro files), can then be assessed with
the root mean square deviation of the quality control standards,

\begin{equation}\label{eq:qlty.contr}
\sigma_\text{rmsd}^{\text{project}} = 
\sqrt{\frac{1}{M}\sum_{i=1}^{M}{\left(\Delta\delta_{i}^{\text{qlty-contr}}\right)^2}},
\end{equation}

where $\Delta\delta_{i}^{\text{qlty-contr}}$ is the deviation for measurement
file $i$ of the quality control standard from its true value.

## Programme work flow

The basic programme workflow in **piccr** for correcting and calibrating the raw
data is:

1.
if (use\_memory\_correction):
    + calculate memory coefficients (using method (1) for the time being);
	+ apply memory correction (using second line of
      Eq. (\ref{eq:delta.mem.corr.}) for the time being).

2.
if (use\_no\_drift\_correction):
	+ obtain calibration intercept and slope from $b_1$ standards;
	+ apply calibration (Eq. \ref{eq:calibration}).

    else if (use\_simple\_drift\_correction):
    + calculate drift slope $\alpha$;
	+ drift-correct data (Eq. \ref{eq:drift.corr.});
	+ obtain calibration intercept and slope from $b_1$ standards;
	+ apply calibration (Eq. \ref{eq:calibration}).

    else if (use\_double\_calibration):
    + obtain calibration intercept and slope from $b_1$ and $b_3$ standards;
	+ linearly regress calibration parameters between $b_1$ and $b_3$;
	+ apply calibration (Eq. \ref{eq:calibration}).

3.
calculate average values across injections.

4.
obtain quality control information.

## References

van Geldern, R. and Barth, J. A.: Optimization of instrument setup and post-run
corrections for oxygen and hydrogen stable isotope measurements of water by
isotope ratio infrared spectroscopy (IRIS), Limnol. Oceanogr. Methods, 10,
1024â1036,
DOI: [10.4319/lom.2012.10.1024](https://doi.org/10.4319/lom.2012.10.1024), 2012.

